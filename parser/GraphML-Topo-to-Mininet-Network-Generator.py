#!/usr/bin/python

#GraphML-Topo-to-Mininet-Network-Generator
#
# This file parses Network Topologies in GraphML format from the Internet Topology Zoo.
# A python file for creating Mininet Topologies will be created as Output.
# Files have to be in the same directory.
#
# Arguments:
#   TODO : make extensions optional
#   TODO find out what the line above did mean
#   -f          [filename to of GraphML input file]
#   --file      [filename to of GraphML input file]
#   -o          [filename to of GraphML output file]
#   --output    [filename to of GraphML output file]
#   -b          [number as integer for bandwidth in mbit]
#   --bw        [number as integer for bandwidth in mbit]
#   --bandwidth [number as integer for bandwidth in mbit]
#
# Without specified input, program will terminate.
# Without specified output, outputfile will have the same name as the input file.
#
# CAUTION: THE GENERATED TOPO WILL NOT RUN AFTER GENERATION!
# YOU FIRST HAVE TO FIX THE HOSTS SECTION IN IT. SEE FIXME COMMENT THERE.
# The topology can be made executable, just look out for the other FIXME comments in the newly generated file..
#
# Created by Stephan Schuberth in 01/2013 to 03/2013



import xml.etree.ElementTree as ET
import sys
import math
import re
from sys import argv

input_file_name = ''
output_file_name = ''
bandwidth_argument = ''

# first check commandline arguments
# TODO use 'argparse', the built-in argument parser of python
# TODO argparse may seem overhead, but it actually eases helpdoc's
for i in range(len(argv)):
    if argv[i] == '-f':
        input_file_name = argv[i+1]
    if argv[i] == '--file':
        input_file_name = argv[i+1]
    if argv[i] == '-o':
        output_file_name = argv[i+1]
    if argv[i] == '--output':
        output_file_name = argv[i+1]
    if argv[i] == '-b':
        bandwidth_argument = argv[i+1]
    if argv[i] == '--bw':
        bandwidth_argument = argv[i+1]
    if argv[i] == '--bandwidth':
        bandwidth_argument = argv[i+1]

# terminate when inputfile is missing
if input_file_name == '':
    sys.exit('\n\tno input file was specified as argument')

# define string fragments for output later on
outputstring_1 = '''#!/usr/bin/python

"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.node import Node
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.cli import CLI
from mininet.log import setLogLevel

class GeneratedTopo( Topo ):
    "Internet Topology Zoo Specimen."

    def __init__( self, **opts ):
        "Create a topology."

        # Initialize Topology
        Topo.__init__( self, **opts )
'''

outputstring_2a='''
        # add nodes
        # switches first
'''
outputstring_2b='''
        # and now hosts
'''

# TODO remove the host adding and
# add a message to remind to not forget the
# hosts after using the generator
# or just remove it completely once the one-host-per-switch generation works
outputstring_3a='''
        # hosts (put here if needed)
        # dont forget to add edges afterwards!

        #FIXME host and links section needs adjusting to your topology needs!!!
        # this are just exemplarical entries,
        # fitting my topology and needs.
        # I left this here as an sample entry.

        #FIXME this was needed before a host per switch was generated and linked

        #node1 = self.addHost( 'h1' )
        #node2 = self.addHost( 'h2' )

        # next tree lines never put to use so far
        #node3 = self.addHost( 'rcv1' )
        #node4 = self.addHost( 'rcv2' )
        #node5 = self.addHost( 'logserv' )

        #self.addLink( HAM , node1 )
        #self.addLink( GAR , node2 )

        # add edges between switch and corresponding host
'''

outputstring_3b='''
        # add edges between switches
'''

outputstring_4='''

topos = { 'generated': ( lambda: GeneratedTopo() ) }

# here the code defining the topology ends
# the following code produces an executable script working with a remote controller
# and ssh access to the the mininet hosts from within the ubuntu vm
def setupNetwork():
    "Create network and run simple performance test"
    topo = GeneratedTopo()
    net = Mininet(topo=topo, controller=lambda a: RemoteController( a, ip='10.0.2.2', port=6633 ), host=CPULimitedHost, link=TCLink)
    #print "Dumping host connections"
    #dumpNodeConnections(net.hosts)
    #print "Testing network connectivity"
    #net.pingAll()
    #print "Testing bandwidth between h1 and h2"
    #h1, h2 = net.getNodeByName('h1', 'h2')
    #net.iperf((h1, h2))
    return net

def connectToRootNS( network, switch, ip, prefixLen, routes ):
    """Connect hosts to root namespace via switch. Starts network.
      network: Mininet() network object
      switch: switch to connect to root namespace
      ip: IP address for root namespace node
      prefixLen: IP address prefix length (e.g. 8, 16, 24)
      routes: host networks to route to"""
    # Create a node in root namespace and link to switch 0
    root = Node( 'root', inNamespace=False )
    intf = TCLink( root, switch ).intf1
    root.setIP( ip, prefixLen, intf )
    # Start network that now includes link to root namespace
    network.start()
    # Add routes from root ns to hosts
    for route in routes:
        root.cmd( 'route add -net ' + route + ' dev ' + str( intf ) )

def sshd( network, cmd='/usr/sbin/sshd', opts='-D' ):
    "Start a network, connect it to root ns, and run sshd on all hosts."
    switch = network.switches[ 0 ]  # switch to use
    ip = '10.123.123.1'  # our IP address on host network
    routes = [ '10.0.0.0/8' ]  # host networks to route to
    connectToRootNS( network, switch, ip, 8, routes )
    for host in network.hosts:
        host.cmd( cmd + ' ' + opts + '&' )
    print
    print "*** Hosts are running sshd at the following addresses:"
    print

    #FIXME: when host lacks an interface because of broken setup process, dont call it!
    #FIXME: host.IP() will trigger a warning and shut mininet down
    #FIXME: (at least on this loglevel, dont know if others are different)
    #for host in network.hosts:
        #print host.name, host.IP()
    #FIXME: because the upper part wont work dynamically,
    #FIXME: the listing (according to the settings just above the print statements above)
    #FIXME: will be static. in case you change the ip above, the next print lines
    #FIXME: will be false: 10.0.0.x will be wrong!
    #FIXME:
    print "use 'ssh 10.0.0.x' from other consoles to connect"
    print
    print "*** Type 'exit' or control-D to shut down network"
    CLI( network )
    for host in network.hosts:
        host.cmd( 'kill %' + cmd )
    network.stop()

if __name__ == '__main__':
    setLogLevel('info')
    #setLogLevel('debug')
    sshd( setupNetwork() )
'''

# where to put results
outputstring_to_be_exported = ''
outputstring_to_be_exported += outputstring_1

# read file and do the actual parsing
tree = ET.parse(input_file_name)
namespace = "{http://graphml.graphdrawing.org/xmlns}"
ns = namespace # just doing shortcutting, namespaces are needed often.

root = tree.getroot()
graph = root.find(ns + 'graph')

#get all entries
nodes = graph.findall(ns + 'node')
edges = graph.findall(ns + 'edge')

# now first generate the id's
node_root_attrib = ''
node_name = ''
longitude = ''
latitude = ''
id_node_dict = {} # to hold all 'id: name' pairs
id_longitude_dict = {}
id_latitude_dict = {}

#get id data
#get longitude datk
#get latitude data
# FIXME here you have to set the correct 'dxy' settings.
# THESE MAY DIFFER IN THE DIFFERENT TOPOLOGY ZOO FILES!!!
for n in nodes:
    node_root_attrib = n.attrib['id']
    data = n.findall(ns + 'data')
    for d in data:
        #node name
        if d.attrib['key'] == 'd33':
        #DFN network
        #if d.attrib['key'] == 'd34':
            #next line strips all whitespace from names
            node_name = re.sub(r'\s+', '', d.text)
        #longitude data
        if d.attrib['key'] == 'd32':
        #DFN network
        #if d.attrib['key'] == 'd33':
            longitude = d.text
        #latitude data
        if d.attrib['key'] == 'd29':
        #DFN network
        #if d.attrib['key'] == 'd30':
            latitude = d.text
        #save data couple
        id_node_dict[node_root_attrib] = node_name
        id_longitude_dict[node_root_attrib] = longitude
        id_latitude_dict[node_root_attrib] = latitude

#create strings
tempstring1 = ''
tempstring2 = ''
# first create the switches and hosts
tempstring = ''
for i in range(0, len(id_node_dict)):
    #create switch
    temp1 =  '        '
    temp1 += id_node_dict[str(i)]
    temp1 += " = self.addSwitch( 's"
    temp1 += str(i)
    temp1 += "' )\n"
    #create corresponding host
    temp2 =  '        '
    temp2 += id_node_dict[str(i)]
    temp2 += "_host = self.addHost( 'h"
    temp2 += str(i)
    temp2 += "' )\n"
    tempstring1 += temp1
    tempstring2 += temp2

outputstring_to_be_exported += outputstring_2a
outputstring_to_be_exported += tempstring1
outputstring_to_be_exported += outputstring_2b
outputstring_to_be_exported += tempstring2
outputstring_to_be_exported += outputstring_3a

# second calculate distances between switches,
#   set global bandwidth and create the edges between switches,
#   and link each single host to its corresponding switch
tempstring3 = ''
tempstring4 = ''
distance = 0.0
latency = 0.0
for e in edges:
    # get ids for easier handling
    src_id = e.attrib['source']
    dst_id = e.attrib['target']
    # calculate
    #formula: (for distance)
    #dist(SP,EP) = arccos{ sin(La[EP]) * sin(La[SP]) + cos(La[EP]) * cos(La[SP]) * cos(Lo[EP] - Lo[SP])} * r
    #r = 6378.137 km
    #formula: (speed of light)
    # v = 2.3 * 10**8 m/s
    #formula: (latency being calculated from distance and light speed)
    #t = distance / speed of light
    #t (in ms) = ( distance in km * 1000 (for meters) ) / ( speed of light / 1000 (for ms))
    firstproduct = math.sin(float(id_latitude_dict[dst_id])) * math.sin(float(id_latitude_dict[src_id]))
    secondproductfirstpart = math.cos(float(id_latitude_dict[dst_id])) * math.cos(float(id_latitude_dict[src_id]))
    secondproductsecondpart = math.cos((float(id_longitude_dict[dst_id])) - (float(id_longitude_dict[src_id])))
    distance = math.radians(math.acos(firstproduct + (secondproductfirstpart * secondproductsecondpart))) * 6378.137

    #t (in ms) = ( distance in km * 1000 (for meters) ) / ( speed of light / 1000 (for ms))
    latency = ( distance * 1000 ) / ( 230000 )

    # bandwidth
    #set bw to 10mbit if nothing was specified otherwise on startup
    if bandwidth_argument == '':
        bandwidth_argument = '10';

    # link each switch and its host...
    temp3 =  '        self.addLink( '
    temp3 += id_node_dict[src_id]
    temp3 += ' , '
    temp3 += id_node_dict[src_id]
    temp3 += "_host )"
    temp3 += '\n'
    # ... and link all corresponding switches with each other
    temp4 =  '        self.addLink( '
    temp4 += id_node_dict[src_id]
    temp4 += ' , '
    temp4 += id_node_dict[dst_id]
    temp4 += ", bw="
    temp4 += bandwidth_argument
    temp4 += ", delay='"
    temp4 += str(latency)
    temp4 += "ms')"
    temp4 += '\n'
    # next line so i dont have to look up other possible settings
    #temp += "ms', loss=0, max_queue_size=1000, use_htb=True)"
    tempstring3 += temp3
    tempstring4 += temp4

outputstring_to_be_exported += tempstring3
outputstring_to_be_exported += outputstring_3b
outputstring_to_be_exported += tempstring4
outputstring_to_be_exported += outputstring_4

# generation finished, write string to file
outputfile = ''
if output_file_name == '':
    output_file_name = input_file_name + '-generated-Mininet-Topo.py'
outputfile = open(output_file_name, 'w')
outputfile.write(outputstring_to_be_exported)
outputfile.close()
print "Generation SUCCESSFUL!"
